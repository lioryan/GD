<!DOCTYPE html>
<html>
<head>
    <title>Loss Function Visualization</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: Arial, sans-serif;
            background: white;
            overflow: hidden;
        }
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .slider-group {
            margin-bottom: 10px;
        }
        input[type="range"] {
            width: 200px;
        }
        #value {
            font-weight: bold;
            color: #333;
        }
        #equation {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            font-size: 1.2em;
            z-index: 1000;
        }
        canvas {
            width: 100vw;
            height: 100vh;
        }
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            font-size: 0.9em;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="slider-group">
            <label>X Position: <span id="x-value">0</span></label><br>
            <input type="range" id="x" min="-5" max="5" value="0" step="0.1">
        </div>
        <div class="slider-group">
            <label>Y Position: <span id="y-value">0</span></label><br>
            <input type="range" id="y" min="-5" max="5" value="0" step="0.1">
        </div>
        <div id="value">Loss Value: 0</div>
    </div>

    <div id="equation">
        L(θ₁, θ₂) = θ₁² + θ₂²
    </div>

    <div id="instructions">
        • Left-click + drag red point to move it on surface<br>
        • Middle-click/Alt + drag to move entire graph<br>
        • Right-click + drag to rotate view<br>
        • Mouse wheel to zoom in/out
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        let rotation = { x: 45, y: 45 };
        let translation = { x: 0, y: 0 };
        let scale = 1;
        let isDragging = false;
        let isRotating = false;
        let isDraggingPoint = false;
        let lastMousePos = { x: 0, y: 0 };
        let currentPos = { x: 0, y: 0 };
        let path = [];

        function loss(x, y) {
            return x * x + y * y;
        }

        function project(x, y, z) {
            const baseScale = Math.min(width, height) / 12;
            const finalScale = baseScale * scale;
            const centerX = width / 2 + translation.x;
            const centerY = height / 2 + translation.y;
            
            const xRot = rotation.x * Math.PI / 180;
            const yRot = rotation.y * Math.PI / 180;
            
            const x1 = x;
            const y1 = y * Math.cos(xRot) - z * Math.sin(xRot);
            const z1 = y * Math.sin(xRot) + z * Math.cos(xRot);
            
            const x2 = x1 * Math.cos(yRot) + z1 * Math.sin(yRot);
            
            return {
                x: x2 * finalScale + centerX,
                y: y1 * finalScale + centerY
            };
        }

        // Inverse projection to get world coordinates from screen coordinates
        function unproject(screenX, screenY) {
            const baseScale = Math.min(width, height) / 12;
            const finalScale = baseScale * scale;
            const centerX = width / 2 + translation.x;
            const centerY = height / 2 + translation.y;
            
            const xRot = rotation.x * Math.PI / 180;
            const yRot = rotation.y * Math.PI / 180;

            // Adjust for translation and scale
            const x = (screenX - centerX) / finalScale;
            const y = (screenY - centerY) / finalScale;

            // Inverse rotation
            const cosY = Math.cos(yRot);
            const sinY = Math.sin(yRot);
            const cosX = Math.cos(xRot);
            const sinX = Math.sin(xRot);

            // Simplified inverse projection for x-y plane
            const x2 = x * cosY;
            const y2 = y / cosX;

            return { x: x2, y: y2 };
        }

        function getColor(height) {
            const maxHeight = 50;
            const normalized = Math.min(height / maxHeight, 1);
            const h = 240 - normalized * 180;
            return `hsl(${h}, 80%, 50%)`;
        }

        function isNearPoint(mouseX, mouseY, pointX, pointY) {
            const proj = project(pointX, pointY, loss(pointX, pointY));
            const distance = Math.sqrt(Math.pow(mouseX - proj.x, 2) + Math.pow(mouseY - proj.y, 2));
            return distance < 10 * scale;
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);
            
            // Draw surface
            for (let x = -5; x <= 5; x += 0.2) {
                for (let y = -5; y <= 5; y += 0.2) {
                    const z = loss(x, y);
                    if (z <= 50) {
                        const proj = project(x, y, z);
                        ctx.beginPath();
                        ctx.arc(proj.x, proj.y, 2 * scale, 0, Math.PI * 2);
                        ctx.fillStyle = getColor(z);
                        ctx.fill();
                    }
                }
            }
            
            // Draw path
            ctx.beginPath();
            for (let i = 0; i < path.length; i++) {
                const proj = project(path[i].x, path[i].y, path[i].z);
                if (i === 0) {
                    ctx.moveTo(proj.x, proj.y);
                } else {
                    ctx.lineTo(proj.x, proj.y);
                }
            }
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2 * scale;
            ctx.stroke();

            // Draw current point
            const z = loss(currentPos.x, currentPos.y);
            const proj = project(currentPos.x, currentPos.y, z);
            
            // Vertical line
            const baseProj = project(currentPos.x, currentPos.y, 0);
            ctx.beginPath();
            ctx.moveTo(proj.x, proj.y);
            ctx.lineTo(proj.x, baseProj.y);
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1 * scale;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Point
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, 6 * scale, 0, Math.PI * 2);
            ctx.fillStyle = isNearPoint(lastMousePos.x, lastMousePos.y, currentPos.x, currentPos.y) ? '#ff6666' : 'red';
            ctx.fill();
        }

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            draw();
        });

        function updateSliders() {
            document.getElementById('x').value = currentPos.x;
            document.getElementById('y').value = currentPos.y;
            document.getElementById('x-value').textContent = currentPos.x.toFixed(1);
            document.getElementById('y-value').textContent = currentPos.y.toFixed(1);
            document.getElementById('value').textContent = `Loss Value: ${loss(currentPos.x, currentPos.y).toFixed(1)}`;
        }

        canvas.addEventListener('mousedown', (e) => {
            lastMousePos = { x: e.clientX, y: e.clientY };
            
            if (e.button === 2) { // Right click
                isRotating = true;
            } else if (e.button === 1 || e.altKey) { // Middle click or Alt+click
                isDragging = true;
            } else if (isNearPoint(e.clientX, e.clientY, currentPos.x, currentPos.y)) {
                isDraggingPoint = true;
            } else {
                isDragging = true;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const mousePos = { x: e.clientX, y: e.clientY };

            if (isDraggingPoint) {
                const unproj = unproject(mousePos.x, mousePos.y);
                currentPos.x = Math.max(-5, Math.min(5, unproj.x));
                currentPos.y = Math.max(-5, Math.min(5, unproj.y));
                updateSliders();
                
                const z = loss(currentPos.x, currentPos.y);
                path.push({ x: currentPos.x, y: currentPos.y, z: z });
                if (path.length > 50) path.shift();
            } else if (isDragging) {
                translation.x += mousePos.x - lastMousePos.x;
                translation.y += mousePos.y - lastMousePos.y;
            } else if (isRotating) {
                rotation.y += (mousePos.x - lastMousePos.x) * 0.5;
                rotation.x += (mousePos.y - lastMousePos.y) * 0.5;
            }
            
            lastMousePos = mousePos;
            draw();
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            isRotating = false;
            isDraggingPoint = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            isRotating = false;
            isDraggingPoint = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale *= delta;
            scale = Math.max(0.1, Math.min(scale, 5));
            draw();
        });

        function updatePosition() {
            currentPos = { 
                x: parseFloat(document.getElementById('x').value), 
                y: parseFloat(document.getElementById('y').value) 
            };
            const z = loss(currentPos.x, currentPos.y);
            
            updateSliders();
            
            path.push({ x: currentPos.x, y: currentPos.y, z: z });
            if (path.length > 50) path.shift();
            
            draw();
        }

        document.getElementById('x').addEventListener('input', updatePosition);
        document.getElementById('y').addEventListener('input', updatePosition);

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        updatePosition();
    </script>
</body>
</html>
