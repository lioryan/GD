<!DOCTYPE html>
<html>
<head>
    <title>Neural Network Unit with Morphing Surface</title>
    <style>
        /* Previous styles remain the same */
        .equation {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 1000;
            font-size: 1.2em;
            line-height: 1.5;
        }
        .loss-display {
            margin-top: 10px;
            font-weight: bold;
            color: #e44;
        }
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        /* Previous styles remain... */
    </style>
</head>
<body>
    <!-- Previous container and controls remain -->

    <div class="equation">
        Loss Function:<br>
        L(θ₁, θ₂) = α(θ₁² + θ₂²)<br>
        <div class="loss-display" id="current-loss">
            Current Loss: 0.0
        </div>
    </div>

    <div id="instructions">
        • Left-click + drag red point to adjust weights<br>
        • Middle-click/Alt + drag to move entire graph<br>
        • Right-click + drag to rotate view<br>
        • Mouse wheel to zoom<br>
        • Use shape slider to morph surface
    </div>

    <script>
        // Previous code remains, adding/modifying these parts:
        let translation = { x: 0, y: 0 };
        let isMovingGraph = false;

        function project(x, y, z) {
            const baseScale = Math.min(width, height) / 12;
            const finalScale = baseScale * scale;
            const centerX = width / 2 + translation.x;  // Added translation
            const centerY = height / 2 + translation.y;  // Added translation
            
            const xRot = rotation.x * Math.PI / 180;
            const yRot = rotation.y * Math.PI / 180;
            
            const x1 = x;
            const y1 = y * Math.cos(xRot) - z * Math.sin(xRot);
            const z1 = y * Math.sin(xRot) + z * Math.cos(xRot);
            
            const x2 = x1 * Math.cos(yRot) + z1 * Math.sin(yRot);
            
            return {
                x: x2 * finalScale + centerX,
                y: y1 * finalScale + centerY
            };
        }

        // Modified event listeners
        surfaceCanvas.addEventListener('mousedown', (e) => {
            lastMousePos = { x: e.clientX, y: e.clientY };
            if (e.button === 2) { // Right click
                isRotating = true;
            } else if (e.button === 1 || e.altKey) { // Middle click or Alt+click
                isMovingGraph = true;
                e.preventDefault(); // Prevent default middle-click behavior
            } else {
                const z = loss(currentPos.x, currentPos.y, morphValue);
                const proj = project(currentPos.x, currentPos.y, z);
                const dx = e.clientX - proj.x;
                const dy = e.clientY - proj.y;
                
                // Check if clicking near the point
                if (Math.sqrt(dx * dx + dy * dy) < 10 * scale) {
                    isDragging = true;
                }
            }
        });

        surfaceCanvas.addEventListener('mousemove', (e) => {
            if (isMovingGraph) {
                translation.x += e.clientX - lastMousePos.x;
                translation.y += e.clientY - lastMousePos.y;
                draw();
            } else if (isRotating) {
                rotation.y += (e.clientX - lastMousePos.x) * 0.5;
                rotation.x += (e.clientY - lastMousePos.y) * 0.5;
                draw();
            } else if (isDragging) {
                // Improved point dragging calculation
                const rect = surfaceCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - translation.x - width/2) / (scale * (Math.min(width, height) / 12));
                const y = (e.clientY - rect.top - translation.y - height/2) / (scale * (Math.min(width, height) / 12));
                
                // Adjust for rotation
                const yRot = rotation.y * Math.PI / 180;
                const xRot = rotation.x * Math.PI / 180;
                
                currentPos.x = x / Math.cos(yRot);
                currentPos.y = y / Math.cos(xRot);
                
                // Clamp values
                currentPos.x = Math.max(-5, Math.min(5, currentPos.x));
                currentPos.y = Math.max(-5, Math.min(5, currentPos.y));
                
                updateSliders();
                draw();
            }
            lastMousePos = { x: e.clientX, y: e.clientY };
        });

        surfaceCanvas.addEventListener('mouseup', () => {
            isDragging = false;
            isRotating = false;
            isMovingGraph = false;
        });

        surfaceCanvas.addEventListener('mouseleave', () => {
            isDragging = false;
            isRotating = false;
            isMovingGraph = false;
        });

        // Modified update function
        function updateSliders() {
            xSlider.value = currentPos.x;
            ySlider.value = currentPos.y;
            document.getElementById('x-value').textContent = currentPos.x.toFixed(1);
            document.getElementById('y-value').textContent = currentPos.y.toFixed(1);
            
            const currentLoss = loss(currentPos.x, currentPos.y, morphValue);
            document.getElementById('value').textContent = `Loss: ${currentLoss.toFixed(1)}`;
            document.getElementById('current-loss').textContent = 
                `Current Loss: ${currentLoss.toFixed(3)}`;
            
            // Update equation to show actual morphing value
            const alpha = morphValue.toFixed(2);
            document.querySelector('.equation').innerHTML = 
                `Loss Function:<br>` +
                `L(θ₁, θ₂) = ${alpha}(θ₁² + θ₂²)<br>` +
                `<div class="loss-display">` +
                `Current Loss: ${currentLoss.toFixed(3)}<br>` +
                `θ₁ = ${currentPos.x.toFixed(2)}, θ₂ = ${currentPos.y.toFixed(2)}` +
                `</div>`;
        }

        // Rest of the code remains the same...
    </script>
</body>
</html>
