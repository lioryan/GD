<!DOCTYPE html>
<html>
<head>
    <title>Neural Network Unit with Morphing Surface</title>
    <style>
        /* Previous styles remain the same */
        #position-controls {
            position: fixed;
            top: 20px;
            right: 50%;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .button-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }
        .position-btn {
            padding: 5px;
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }
        .position-btn:hover {
            background: #e0e0e0;
        }
        .center-btn {
            grid-column: span 3;
        }
        /* Rest of previous styles... */
    </style>
</head>
<body>
    <!-- Previous containers and controls remain -->

    <div id="position-controls">
        <div class="button-group">
            <button class="position-btn" onclick="moveGraph('upLeft')">↖</button>
            <button class="position-btn" onclick="moveGraph('up')">↑</button>
            <button class="position-btn" onclick="moveGraph('upRight')">↗</button>
            <button class="position-btn" onclick="moveGraph('left')">←</button>
            <button class="position-btn center-btn" onclick="centerGraph()">Center</button>
            <button class="position-btn" onclick="moveGraph('right')">→</button>
            <button class="position-btn" onclick="moveGraph('downLeft')">↙</button>
            <button class="position-btn" onclick="moveGraph('down')">↓</button>
            <button class="position-btn" onclick="moveGraph('downRight')">↘</button>
        </div>
    </div>

    <script>
        // Previous variables remain...
        let translation = { x: 0, y: 0 };
        const MOVE_STEP = 50; // Pixels to move per button click

        function moveGraph(direction) {
            switch(direction) {
                case 'up':
                    translation.y -= MOVE_STEP;
                    break;
                case 'down':
                    translation.y += MOVE_STEP;
                    break;
                case 'left':
                    translation.x -= MOVE_STEP;
                    break;
                case 'right':
                    translation.x += MOVE_STEP;
                    break;
                case 'upLeft':
                    translation.x -= MOVE_STEP;
                    translation.y -= MOVE_STEP;
                    break;
                case 'upRight':
                    translation.x += MOVE_STEP;
                    translation.y -= MOVE_STEP;
                    break;
                case 'downLeft':
                    translation.x -= MOVE_STEP;
                    translation.y += MOVE_STEP;
                    break;
                case 'downRight':
                    translation.x += MOVE_STEP;
                    translation.y += MOVE_STEP;
                    break;
            }
            draw();
        }

        function centerGraph() {
            translation = { x: 0, y: 0 };
            draw();
        }

        // Modified event handlers for better graph movement
        let isDraggingGraph = false;
        let dragStartPos = { x: 0, y: 0 };
        let originalTranslation = { x: 0, y: 0 };

        surfaceCanvas.addEventListener('mousedown', (e) => {
            lastMousePos = { x: e.clientX, y: e.clientY };
            dragStartPos = { x: e.clientX, y: e.clientY };
            originalTranslation = { ...translation };

            if (e.button === 2) { // Right click
                isRotating = true;
            } else if (e.button === 1 || e.altKey) { // Middle click or Alt+click
                e.preventDefault();
                isDraggingGraph = true;
            } else {
                // Check if clicking near the point
                const z = loss(currentPos.x, currentPos.y, morphValue);
                const proj = project(currentPos.x, currentPos.y, z);
                const dx = e.clientX - proj.x;
                const dy = e.clientY - proj.y;
                
                if (Math.sqrt(dx * dx + dy * dy) < 10 * scale) {
                    isDragging = true;
                }
            }
        });

        surfaceCanvas.addEventListener('mousemove', (e) => {
            if (isDraggingGraph) {
                translation.x = originalTranslation.x + (e.clientX - dragStartPos.x);
                translation.y = originalTranslation.y + (e.clientY - dragStartPos.y);
                draw();
            } else if (isRotating) {
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                rotation.y += deltaX * 0.5;
                rotation.x += deltaY * 0.5;
                draw();
            } else if (isDragging) {
                // Improved point dragging with rotation compensation
                const rect = surfaceCanvas.getBoundingClientRect();
                const centerX = width / 2 + translation.x;
                const centerY = height / 2 + translation.y;
                
                // Calculate position relative to center
                const dx = (e.clientX - rect.left - centerX) / (scale * (Math.min(width, height) / 12));
                const dy = (e.clientY - rect.top - centerY) / (scale * (Math.min(width, height) / 12));
                
                // Compensate for rotation
                const cosY = Math.cos(rotation.y * Math.PI / 180);
                const sinY = Math.sin(rotation.y * Math.PI / 180);
                const cosX = Math.cos(rotation.x * Math.PI / 180);
                
                currentPos.x = (dx * cosY - dy * sinY);
                currentPos.y = dy / cosX;
                
                // Clamp values
                currentPos.x = Math.max(-5, Math.min(5, currentPos.x));
                currentPos.y = Math.max(-5, Math.min(5, currentPos.y));
                
                updateSliders();
                draw();
            }
            lastMousePos = { x: e.clientX, y: e.clientY };
        });

        surfaceCanvas.addEventListener('mouseup', () => {
            isDragging = false;
            isRotating = false;
            isDraggingGraph = false;
        });

        surfaceCanvas.addEventListener('mouseleave', () => {
            isDragging = false;
            isRotating = false;
            isDraggingGraph = false;
        });

        // Prevent text selection during dragging
        document.addEventListener('selectstart', (e) => {
            if (isDragging || isRotating || isDraggingGraph) {
                e.preventDefault();
            }
        });

        // Modified project function for better coordinate handling
        function project(x, y, z) {
            const baseScale = Math.min(width, height) / 12;
            const finalScale = baseScale * scale;
            const centerX = width / 2 + translation.x;
            const centerY = height / 2 + translation.y;
            
            const xRot = rotation.x * Math.PI / 180;
            const yRot = rotation.y * Math.PI / 180;
            
            // Improved projection calculations
            const cosX = Math.cos(xRot);
            const sinX = Math.sin(xRot);
            const cosY = Math.cos(yRot);
            const sinY = Math.sin(yRot);
            
            const x1 = x;
            const y1 = y * cosX - z * sinX;
            const z1 = y * sinX + z * cosX;
            
            const x2 = x1 * cosY + z1 * sinY;
            
            return {
                x: x2 * finalScale + centerX,
                y: y1 * finalScale + centerY
            };
        }

        // Rest of the code remains the same...
    </script>
</body>
</html>
